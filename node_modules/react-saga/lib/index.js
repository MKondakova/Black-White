'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Group = undefined;
exports.createElement = createElement;
exports.render = render;
exports.reactSaga = reactSaga;

var _immutable = require('immutable');

var Immutable = _interopRequireWildcard(_immutable);

var _reduxSaga = require('redux-saga');

var _effects = require('redux-saga/effects');

var _react = require('react');

var _isGeneratorFunction = require('is-generator-function');

var _isGeneratorFunction2 = _interopRequireDefault(_isGeneratorFunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var makeSagaDescriptor = Immutable.Record({ saga: null, props: null }, 'SagaDescriptor');
function isGenerator(fun) {
    return (0, _isGeneratorFunction2.default)(fun) || typeof regeneratorRuntime !== 'undefined' && regeneratorRuntime.isGeneratorFunction(fun);
}
function isValidChild(object) {
    if (!object) {
        return true;
    }
    return typeof object.type === 'function';
}
var Group = exports.Group = function Group(props) {
    return null;
};
function createElement(cls, props) {
    for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        children[_key - 2] = arguments[_key];
    }

    return {
        type: cls,
        props: (children.length ? Object.assign({}, props, { children: children }) : props) || {},
        key: null
    };
}
function isFunctionElement(node) {
    return typeof node.type === 'function';
}
function childCheckFail(node) {
    throw new Error('invalid node type ' + (node && node.type));
}
function renderGroup(node, state) {
    var children = [];
    if (node.props && node.props.children) {
        if ({}.toString.call(node.props.children) === '[object Array]') {
            node.props.children.forEach(function (child) {
                if (isValidChild(child)) {
                    children.push.apply(children, _toConsumableArray(render(child, state)));
                } else {
                    childCheckFail(node);
                }
            });
        } else {
            _react.Children.forEach(node.props.children, function (child) {
                if (isValidChild(child)) {
                    children.push.apply(children, _toConsumableArray(render(child, state)));
                } else {
                    childCheckFail(node);
                }
            });
        }
    }
    return children;
}
function render(node, state) {
    if (!node) {
        return [];
    }
    if (isFunctionElement(node)) {
        if (node.type === Group) {
            return renderGroup(node, state);
        } else if (isGenerator(node.type)) {
            var descriptor = makeSagaDescriptor({
                saga: node.type,
                props: Immutable.fromJS(node.props)
            });
            return [descriptor];
        } else {
            return render(node.type(Object.assign({}, node.props, { state: state })), state);
        }
    }
    return childCheckFail(node);
}
function getSagas(node, state) {
    return Immutable.OrderedSet(render(node, state));
}
function forkDescriptor(spec) {
    return (0, _effects.fork)(spec.saga, spec.props.toJS());
}
function reactSaga(node, debugFn) {
    return (/*#__PURE__*/regeneratorRuntime.mark(function reactSaga() {
            var _marked, runningSagas, step;

            return regeneratorRuntime.wrap(function reactSaga$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            step = function step() {
                                var state, sagas, kill, spawn, keep, killEffects, spawnEffects, result;
                                return regeneratorRuntime.wrap(function step$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                _context.next = 2;
                                                return (0, _effects.select)();

                                            case 2:
                                                state = _context.sent;
                                                sagas = getSagas(node, state);
                                                kill = runningSagas.keySeq().filter(function (spec) {
                                                    return !sagas.contains(spec);
                                                });
                                                spawn = sagas.filter(function (spec) {
                                                    return !runningSagas.has(spec);
                                                });
                                                keep = runningSagas.filter(function (_, spec) {
                                                    return sagas.contains(spec);
                                                });

                                                if (!(kill.isEmpty() && spawn.isEmpty())) {
                                                    _context.next = 9;
                                                    break;
                                                }

                                                return _context.abrupt('return');

                                            case 9:
                                                killEffects = kill.map(function (spec) {
                                                    return runningSagas.get(spec);
                                                }).map(_effects.cancel).toArray();
                                                spawnEffects = spawn.map(forkDescriptor).toArray();

                                                if (debugFn) {
                                                    kill.forEach(function (spec) {
                                                        debugFn('kill %s', spec.saga.name, spec.props.toJS());
                                                    });
                                                    spawn.forEach(function (spec) {
                                                        debugFn('spawn %s', spec.saga.name, spec.props.toJS());
                                                    });
                                                }
                                                _context.next = 14;
                                                return [].concat(_toConsumableArray(killEffects), _toConsumableArray(spawnEffects));

                                            case 14:
                                                result = _context.sent;

                                                runningSagas = Immutable.OrderedMap(keep.concat(spawn.toList().zip(Immutable.Iterable(result).slice(killEffects.length))));

                                            case 16:
                                            case 'end':
                                                return _context.stop();
                                        }
                                    }
                                }, _marked, this);
                            };

                            _marked = /*#__PURE__*/regeneratorRuntime.mark(step);
                            runningSagas = Immutable.OrderedMap();
                            _context2.prev = 3;
                            return _context2.delegateYield(step(), 't0', 5);

                        case 5:
                            return _context2.delegateYield((0, _reduxSaga.takeLatest)('*', step), 't1', 6);

                        case 6:
                            _context2.prev = 6;
                            return _context2.delegateYield(runningSagas.valueSeq().map(_effects.cancel).toArray(), 't2', 8);

                        case 8:
                            return _context2.finish(6);

                        case 9:
                        case 'end':
                            return _context2.stop();
                    }
                }
            }, reactSaga, this, [[3,, 6, 9]]);
        })
    );
}